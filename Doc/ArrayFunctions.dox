/**
	\file    ArrayFunctions.dox
	\brief   Documentation of the arrays functions.
	\author  R. Kerviche
	\date    December 1st 201
**/

/*
	This file is not needed for the library to work. It mirrors the definitions in $KARTET_PATH/include/Core/ArrayFunctions.hpp.
*/

namespace Kartet
{
/**
	\addtogroup FunctionsGroup
	@{
**/

// Some of the functions are obtained from http://docs.nvidia.com/cuda/cuda-math-api/group__CUDA__MATH__DOUBLE.html#group__CUDA__MATH__DOUBLE

// Internal tools :
	/**
	\return The current row index.
	**/
	index_t IndexI(void) { }

	/**
	\return The current column index.
	**/
	index_t IndexJ(void) { }

	/**
	\return The current slice index.
	**/
	index_t IndexK(void) { }

	/**
	\return The current row index from the end.
	**/
	index_t IndexEndI(void) { }

	/**
	\return The current column index from the end.
	**/
	index_t IndexEndJ(void) { }

	/**
	\return The current slice index from the end.
	**/
	index_t IndexEndK(void) { }

	/**
	\return The current normalized row index in [0.0f, 1.0f[.
	**/
	float INormExclf(void) { }

	/**
	\return The current normalized column index in [0.0f, 1.0f[.
	**/
	float JNormExclf(void) { }

	/**
	\return The current normalized slice index in [0.0f, 1.0f[.
	**/
	float KNormExclf(void) { }

	/**
	\return The current normalized row index in [0.0f, 1.0f].
	**/
	float INormInclf(void) { }

	/**
	\return The current normalized column index in [0.0f, 1.0f].
	**/
	float JNormInclf(void) { }

	/**
	\return The current normalized slice index in [0.0f, 1.0f].
	**/
	float KNormInclf(void) { }

	/**
	\return The current normalized row index in [0.0, 1.0[.
	**/
	double INormExcl(void) { }

	/**
	\return The current normalized column index in [0.0, 1.0[.
	**/
	double JNormExcl(void) { }

	/**
	\return The current normalized slice index in [0.0, 1.0[.
	**/
	double KNormExcl(void) { }

	/**
	\return The current normalized row index in [0.0, 1.0].
	**/
	double INormIncl(void) { }

	/**
	\return The current normalized column index in [0.0, 1.0].
	**/
	double JNormIncl(void) { }

	/**
	\return The current normalized slice index in [0.0, 1.0].
	**/
	double KNormIncl(void) { }

	/**
	\return The current index.
	**/
	index_t Index(void) { }

	/**
	\return True if the element is on the main diagonal.
	**/
	bool Identityb(void) { }

	/**
	\return 1.0f if the element is on the main diagonal.
	**/
	float Identityf(void) { }

	/**
	\return 1.0 if the element is on the main diagonal.
	**/
	double Identity(void) { }

	/**
	\return True if the element is in the upper triangular part (including the main diagonal).
	**/
	bool UpperTriangleb(void) { }

	/**
	\return 1.0f if the element is in the upper triangular part (including the main diagonal).
	**/
	float UpperTrianglef(void) { }

	/**
	\return 1.0 if the element is in the upper triangular part (including the main diagonal).
	**/
	double UpperTriangle(void) { }

	/**
	\return True if the element is in the lower triangular part (including the main diagonal).
	**/
	bool LowerTriangleb(void) { }

	/**
	\return 1.0f if the element is in the lower triangular part (including the main diagonal).
	**/
	float LowerTrianglef(void) { }

	/**
	\return 1.0 if the element is in the lower triangular part (including the main diagonal).
	**/
	double LowerTriangle(void) { }

	/**
	\return The radius at the current location from the center of the array.
	**/
	float Radiusf(void) { }

	/**
	\return The radius at the current location from the center of the array.
	**/
	double Radius(void) { }

	/**
	\return The normalized radius at the current location from the center of the array.
	**/
	float RadiusNormalizedf(void) { }

	/**
	\return The normalized radius at the current location from the center of the array.
	**/
	double RadiusNormalized(void) { }

	/**
	\return The complex conjugate of the argument.
	\param a Expression.
	**/
	Result conj(Expression a) { }

// Double or automatic Precision : 
	/**
	\return The cosine of the argument.
	\param a Real expression.
	**/
	T cos(Expression a) { }

	/**
	\return The cosine of the argument.
	\param a Real expression.
	**/
	float cosf(Expression a) { }

	/**
	\return The sine of the argument.
	\param a Real expression.
	**/
	T sin(Expression a) { }

	/**
	\return The sine of the argument.
	\param a Real expression.
	**/
	float sinf(Expression a) { }

	/**
	\return The square root of the argument.
	\param a Real expression.
	**/
	T sqrt(Expression a) { }

	/**
	\return The square root of the argument.
	\param a Real expression.
	**/
	float sqrtf(Expression a) { }

	/**
	\return The exponential of the argument.
	\param a Real expression.
	**/
	T exp(Expression a) { }

	/**
	\return The exponential of the argument.
	\param a Real expression.
	**/
	float expf(Expression a) { }

	/**
	\return The natural logarithm of the argument.
	\param a Real expression.
	**/
	T log(Expression a) { }

	/**
	\return The natural logarithm of the argument.
	\param a Real expression.
	**/
	float logf(Expression a) { }

	/**
	\return The arc-cosine of the argument.
	\param a Real expression.
	**/
	T acos(Expression a) { }

	/**
	\return The hyperbolic arc-cosine of the argument.
	\param a Real expression.
	**/
	T acosh(Expression a) { }

	/**
	\return The arc-sine of the argument.
	\param a Real expression.
	**/
	T asin(Expression a) { }
	
	/**
	\return The hyperbolic arc-sine of the argument.
	\param a Real expression.
	**/
	T asinh(Expression a) { }

	/**
	\return The arc-tangent of the argument.
	\param a Real expression.
	**/
	T atan(Expression a) { }

	/**
	\return The arc-tangent of the argument (within quadrant).
	\param a Real expression.
	**/
	T atan2(Expression a) { }

	/**
	\return The hyperbolic arc-tangent of the argument.
	\param a Real expression.
	**/
	T atanh(Expression a) {Â }

	/**
	\return The cube root of the argument.
	\param a Real expression.
	**/
	T cbrt(Expression a) { }

	/**
	\return The ceiling of the argument.
	\param a Real expression.
	**/
	T ceil(Expression a) { }

	/**
	\return The hyperbolic cosine of the argument.
	\param a Real expression.
	**/
	T cosh(Expression a) { }

	/**
	\return The cosine of the argument times Pi.
	\param a Real expression
	**/
	T cospi(Expression a) { }

	/**
	\return The error function for the argument.
	\param a Real expression.
	**/
	T erf(Expression a) { }

	/**
	\return 
	**/
	// erfc
	// erfcinv
	// erfcx
	// erfinv

	/**
	\return The exponential of the argument in base 10.
	\param a Real expression.
	**/
	double exp10(Expression a) { } 

	/**
	\return The exponential of the argument in base 2.
	\param a Real expression.
	**/
	double exp2(Expression a) { }

	// expm1

	/**
	\return The floor value of the argument.
	\param a Real expression.
	**/
	double floor(Expression a) { } 

// Single precision :

	/*
	TO BE DOCUMENTED :
		::ilogb(a)
		isfinite(a)
		isinf(a)
		isnan(a)
		::j0(a)
		::j1(a)
		::lgamma(a)
		::log10(a)
		::log2(a)
		::log1p(a)
		::lrint(a)
		::lround(a)
		::rcbrt(a)
		::rint(a)
		::round(a)
		::rsqrt(a)
		::sinh(a)
		::sinpi(a)
		::tan(a)
		::tanh(a)
		::tgamma(a)
		::trunc(a)
		::y0(a)
		::y1(a)
		::acosf(a)
		::acoshf(a)
		::asinf(a)
		::asinhf(a)
		::atanf(a)
		::atan2f(a)
		::atanhf(a)
		::cbrtf(a)
		::ceilf(a)
		::coshf(a)
		::cospif(a)
		::erff(a)
		::erfcf(a)
		::erfcinvf(a)
		::erfcxf(a)
		::erfinvf(a)
		::exp10f(a)
		::exp2f(a)
		::floorf(a)
		::ilogbf(a)
		::j0f(a)
		::j1f(a)
		::lgammaf(a)
		::log10f(a)
		::log2f(a)
		::lrintf(a)
		::lroundf(a)
		::rcbrtf(a)
		::rintf(a)
		::roundf(a)
		::rsqrtf(a)
		::sinhf(a)
		::sinpif(a)
		::tanf(a)
		::tanhf(a)
		::tgammaf(a)
		::truncf(a)
		::y0f(a)
		::y1f(a)
		::normcdff(a)
		::normcdf(a)
		::normcdfinvf(a)
		::normcdfinv(a
		real
		imag
		abs
		absSq
		angle
		angleToComplex
		piAngleToComplex
		cast

	// Transform functions :
		fftshift
		ifftshift
		xFlip
		yFlip
		distributeSlice
		distributeVector
		distributeElement
		diagonalVector
		distributeElementsOnColumns
		distributeElementsOnSlices
		transpose
		forceUpSymmetry
		forceDownSymmetry

	// Layout reinterpretation functions :
		clamp
		repeat
		expandf
		expand

	// Binary functions : 
		min
		max
		atan2
		fmax
		fmin
		fmod
		hypot
		jn
		ldexp
		pow
		remainder
		yn
		atan2f
		fmaxf
		fminf
		fmodf
		hypotf
		jnf
		ldexpf
		powf
		remainderf
		ynf
		toComplex
		toFloatComplex
		toDoubleComplex

	// Shuffle functions :
		shuffleIndex
		shuffleRows
		shuffleColumns
		shuffleSlices
	*/

/**
	@}
**/
}

